---
title: "[Research] 악성코드 분석용 VM 세팅을 자동화해보자! Part 2"
author: idioth
tags: [idioth, malware, automated, virtual machine, powershell]
categories: [Research]
date: 2021-07-18 18:00:00
cc: true
index_img: /2021/07/18/idioth/setting_malware_vm_part2/thumbnail.png
---

![](setting_malware_vm_part2/thumbnail.png)

# 서론

안녕하세요. idioth입니다. 요즘 날씨가 너무 더워서 아무것도 하기가 싫네요... COVID-19도 심해져서 집에서 공부를 하고 있는데 악성코드 분석을 하려고 보니 환경이 세팅된 가상 머신이 없네요?

![](setting_malware_vm_part2/Untitled%201.png)

급하게 깔아버린 Windows입니다. 아무것도 없군요. 하나하나 설치하기가 귀찮습니다. 하지만 저번 시간에 우리가 진행했던 것이 있죠? 오늘은 애플리케이션 설치 및 바탕화면 바로가기, 작업표시줄 고정을 해봅시다!!!

<center><img src="./SeekPng.com_anime-face-png_136767.png" width="50%" height="50%"></center>

하지만 그것조차 너무 하기가 귀찮네요...... 그래도 한 번 시작한 일은 마무리 지어야 하니 시작해봅시다.

# Chocolatey

Linux 계열 운영체제에서 자동 설정 스크립트를 만들 때 패키지 매니저를 사용하여 간단하게 install 합니다.

```
sudo apm install <package>
```

하지만 WIndows Powershell이나 명령 프롬프트에서는 그러한 기능이 딱히 생각이 나지 않습니다. 일일이 찾아가서 다운로드를 눌러 Windows Installer 등을 실행하여 설치하는 경우가 많죠.

간단하게 설치하고 싶은 분들! 소프트웨어 자동화를 하고 싶은 분들!을 위해 Windows에는 [chocolatey](https://chocolatey.org/)가 있습니다!

![](setting_malware_vm_part2/Untitled%202.png)

chocolatey는 우분투의 apm처럼 windows에서 패키지를 명령줄로 다운로드할 수 있게 만들어줍니다.

![](setting_malware_vm_part2/Untitled%203.png)

세상에 그럼 설치를 해보도록 할까요?

![](setting_malware_vm_part2/Untitled%204.png)

'Get Started'를 클릭하면 아래와 같이 설치하는 방법이 나와있습니다. 영어로 적혀 있고 상당히 길죠? 제가 요약해드리도록 하겠습니다. Powershell을 관리자 권한으로 실행한 후 `Set-ExecutionPolicy Unrestricted`(추후 실행할 우리의 스크립트를 위함 ㅎ)로 설정하고 다음 명령을 복사해 실행해주면 됩니다.

```powershell
Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))
```

![](setting_malware_vm_part2/Untitled%205.png)

chocolatey의 설치가 완료되었다면 어떤 패키지가 있는지 확인해볼 수 없겠죠? Find Packages를 클릭하여 어떤 것들이 있는지 확인해봅시다.

![](setting_malware_vm_part2/Untitled%206.png)

8533개의 패키지가 있다네요! ida도 있는지 확인을 해볼까요?

![](setting_malware_vm_part2/Untitled%207.png)

IDA free의 최신 버전이 올라와있는 것을 확인할 수 있습니다! 사실 첫 스크립트를 작성하고 게시글을 준비할 때 hex-rays 기능이 없는 IDA만 업로드되어 있어서 함수를 짜서 다운로드를 하도록 하였으나... 게시글을 올릴 시점이 되니까 업데이트가 되어 있더라고요? 하핫...

아무튼! chocolatey를 설치하고 난 후에는 apm을 사용하는 것처럼 `choco install <package>`를 통해 애플리케이션을 설치할 수 있습니다. 세상에 너무 간편하잖아? 업데이트도 똑같이 `choco upgrade <package>`를 통해 진행할 수 있어요. chocolatey 자체를 업데이트한다면 `choco upgrade chocolatey`를 해주면 됩니다.

설치된 애플리케이션들은 보통 `%ProgramData%\chocolatey\lib`의 하위 폴더에 생성되니 기억해두세요! (Wireshark, HxD, VSCode 등은 본래의 설치 경로에 설치됩니다.)

# Chocolatey를 활용한 애플리케이션 다운로드

우리에겐 chocolatey가 있으므로 다운로드는 걱정할 필요가 없습니다. 다운로드할 패키지 이름만 정해주면 알아서 다운로드해줄 테니까요.

```powershell
function download_apps
{
    # tools list
    $packages = @(
        "hxd"
        "7zip"
        "ghidra"
        "vscode"
        "procmon"
        "procexp"
        "processhacker"
        "python"
        "die"
        "pestudio"
        "googlechrome"
        "autoruns"
        "wireshark"
        "hashmyfiles"
        "strings"
        "ida-free"
    )

    foreach ($package in $packages)
    {
        choco install $package -y
    }
}
```

`$packages`에 존재하는 패키지는 취향에 따라 추가, 제거, 수정하셔서 사용하시면 됩니다. 매우 매우 간단하죠? 이제 이 스크립트를 실행하여 애플리케이션을 다운로드해봅시다.

![](setting_malware_vm_part2/Untitled%208.png)

`download_apps` 함수만 실행했을 뿐인데 알아서 다 다운로드 받아주고 있네요. 호호 기특한 녀석입니다. 그러면 이제 설치된 파일들을 입맛에 따라 바탕화면 바로가기, 작업 표시줄 고정을 해줘야겠죠?

![](setting_malware_vm_part2/Untitled%209.png)

> ~~아 벌써 귀찮다.. 그냥 침대에 누워서 쉬고 싶다...~~

# 바탕화면 바로가기 만들기

Powershell 스크립트를 사용해 바탕화면 바로가기를 만드는 작업은 매우 간단합니다. WScript를 통해 CreateShortcut만 해주면 돼요!

```powershell
function create_desktop_shortcut
{
    param (
        [string]$src,
        [string]$filename
    )
    
    $dst = Join-Path $env:userprofile "Desktop\$filename.lnk"
    $shell = New-Object -ComObject WScript.Shell
    $shortcut = $shell.CreateShortcut($dst)
    $shortcut.TargetPath = $src
    $shortcut.Save()
}
```

`$src`는 바로가기를 만들 파일의 경로, `$filename`은 바로가기로 생성될 파일 이름입니다. 바탕화면에 생성할 것이기 때문에 `$dst`는 바탕화면으로 고정이 되어있지만, 다른 곳에 만드는 걸 선호한다! 하시면 수정하셔도 되고 `$dst` 자체를 파라미터로 받으셔도 상관없습니다. :)

요로코롬 해주면 간단하게 바탕화면 바로가기도 생성 가능!

![](setting_malware_vm_part2/Untitled%2010.png)

뭐야... 이 부분은 너무 쉽잖아? 작업 표시줄 고정도 단숨에 해치워 버려야겠군...

# 작업 표시줄 고정하기

바탕화면 바로가기는 매우 매우 단순했죠? 작업 표시줄 고정하는 것도 매우 매우 단순합니다! 3줄이면 돼요!

```powershell
function pin_taskbar
{
    param (
        [string]$src
    )

    $shell = New-Object -ComObject "Shell.Application"
    $pin = $shell.NameSpace((Get-Item $src).DirectoryName).ParseName((Get-Item $src).Name)
    $pin.InvokeVerb("taskbarpin")
}
```

자 이제 이걸 실행해주면 됩니다! 아하하 너무 쉽다!

.

.

.

![](setting_malware_vm_part2/Untitled%2011.png)

놀라울 만큼 아무 일도 일어나지 않았습니다. 왜지??? 무슨 일이지??? `$pin.Verbs()`를 통해 확인을 해봅시다.

![](setting_malware_vm_part2/Untitled%2012.png)

없습니다. 네. 작업 표시줄에 고정이 없어요.

![](setting_malware_vm_part2/Untitled%2013.png)

여기에는 있는데 왜? 왜 저기에는 없는 거지...??? 하지만 인생에 불가능은 없는 법. 없으면 만들어주면 되지 않을까요?

아래의 코드를 통해 `Verbs()`에 Taskbar pin 기능을 활성화해봅시다.

```powershell
$value_data = (Get-ItemProperty("HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\" +
    "Explorer\CommandStore\shell\Windows.taskbarpin")).ExplorerCommandHandler

$classes_key = (Get-Item "HKCU:\SOFTWARE\Classes").OpenSubKey("*", $true)
$shell_key = $classes_key.CreateSubKey("shell", $true)
$verb_key = $shell_key.CreateSubKey("taskbarpin", $true)
$verb_key.SetValue("ExplorerCommandHandler", $value_data)
```

`$value_data`는 `Windows.taskbarpin`의 `ExplorerCommandHandler`의 값을 가져옵니다. 그 후 `HKEY_CURRENT_USER`에 `Classes`에 `shell`과 `taskbarpin`을 만들어서 해당 핸들러의 값을 추가해주면 됩니다. `$pin.verbs()`로 확인을 해볼까요?

![](setting_malware_vm_part2/Untitled%2014.png)

taskbarpin이 추가된 것을 확인할 수 있습니다! 이제 `$pin.InvokeVerb("taskbarpin")`을 통해 `taskbarpin`을 호출해봅시다. 제발 되기를 바라며!

![](setting_malware_vm_part2/Untitled%2015.png)

![](setting_malware_vm_part2/Untitled%2016.png)

실험 삼아 vscode의 경로를 줬는데 성공적으로 추가되었네요! 이제 원하는 것들을 작업 표시줄에 추가해주면 됩니다. 하지만 그전에...

![](setting_malware_vm_part2/Untitled%2017.png)

여기에 우리가 만든 `taskbarpin`이 남아있네요...? 이 녀석의 레지스트리를 지워야겠어요.

```powershell
$shell_key.DeleteSubKey("taskbarpin")
if($shell_key.SubKeyCount -eq 0 -and $shell_key.ValueCount -eq 0)
{
    $classes_key.DeleteSubKey("shell")
}
```

짠. 이렇게 그냥 지워버리면 됩니다!

# 전체 코드

이제 완성을 해버렸네요. `application.psm1`의 전체 코드를 확인해봅시다!

```powershell
function download_apps
{
    # tools list
    $packages = @(
        "hxd"
        "7zip"
        "ghidra"
        "vscode"
        "procmon"
        "procexp"
        "processhacker"
        "python"
        "die"
        "pestudio"
        "googlechrome"
        "autoruns"
        "wireshark"
        "hashmyfiles"
        "strings"
        "ida-free"
    )

    foreach ($package in $packages)
    {
        choco install $package -y
    }
}

# refer: https://dotnet-helpers.com/powershell/create-shortcuts-on-desktops-using-powershell/
function create_desktop_shortcut
{
    param (
        [string]$src,
        [string]$filename
    )
    
    $dst = Join-Path $env:userprofile "Desktop\$filename.lnk"
    $shell = New-Object -ComObject WScript.Shell
    $shortcut = $shell.CreateShortcut($dst)
    $shortcut.TargetPath = $src
    $shortcut.Save()
}

# refer: https://stackoverflow.com/questions/31720595/pin-program-to-taskbar-using-ps-in-windows-10
function pin_taskbar
{
    param (
        [string]$src
    )

    $value_data = (Get-ItemProperty("HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\" +
    "Explorer\CommandStore\shell\Windows.taskbarpin")).ExplorerCommandHandler

    $classes_key = (Get-Item "HKCU:\SOFTWARE\Classes").OpenSubKey("*", $true)
    $shell_key = $classes_key.CreateSubKey("shell", $true)
    $verb_key = $shell_key.CreateSubKey("taskbarpin", $true)
    $verb_key.SetValue("ExplorerCommandHandler", $value_data)

    $shell = New-Object -ComObject "Shell.Application"
    $pin = $shell.NameSpace((Get-Item $src).DirectoryName).ParseName((Get-Item $src).Name)
    $pin.InvokeVerb("taskbarpin")

    $shell_key.DeleteSubKey("taskbarpin")
    if($shell_key.SubKeyCount -eq 0 -and $shell_key.ValueCount -eq 0)
    {
        $classes_key.DeleteSubKey("shell")
    }
}
```

생각보다 기능이 많이 없죠? 하지만 이걸로도 간단하게 자동화 스크립트를 만들 수 있다는 사실! 이전에 만들었던 `install.ps1`에 원하는 부분을 추가하고 실행을 해봅시다. +_+

```powershell
# download apps
download_apps

# create desktop shortcut
create_desktop_shortcut "C:\Program Files\Wireshark\Wireshark.exe" "Wireshark"

# pin taskbar
pin_taskbar "C:\ProgramData\chocolatey\lib\procexp\tools\procexp.exe"
pin_taskbar "C:\ProgramData\chocolatey\lib\procexp\tools\procexp64.exe"
pin_taskbar "C:\ProgramData\chocolatey\lib\die\tools\die_win64_portable\die.exe"
pin_taskbar "C:\ProgramData\chocolatey\lib\PeStudio\tools\pestudio\pestudio.exe"
pin_taskbar "C:\Program Files\Microsoft VS Code\Code.exe"
```

![](setting_malware_vm_part2/Untitled%2018.png)

짠! 우리가 고대하던 것들이 스크립트 하나로 끝났습니다. 작업 표시줄에도 고정되었고, Wireshark도 바탕화면 바로가기로 만들어졌네요!

![](setting_malware_vm_part2/Untitled%2019.png)

하얗게 불태워 버렸습니다.

# 마치며...

기술적으로 어려운 부분도 아니고 단지 처음 만들고 찾아보기가 굉장~~~히 귀찮은 작업이라고 생각합니다. 사실상 기능들은 stack overflow에 다 나와 있어서 현재 버전에 사용되지 않으면 사용되는 부분을 찾거나 하면 되거든요. 해당 스크립트는 [MSEdge on Win10 (x64) Stable 1809 버전](https://developer.microsoft.com/en-us/microsoft-edge/tools/vms/)을 기준으로 작성되었습니다. 악성코드 분석을 할 때 항상 저걸 사용해서 하거든요 :)

따라서 현재 OS 버전 21H1에서는 동작하지 않을 수도 있습니다. (실제로 로컬에 테스트를 했을 때 작업표시줄 고정이 안되더군요... 일시적인 건가? 아무튼 이것 때문에 삽질을 좀 했습니다... ㅠㅠ)

추가적으로 아쉬운 부분은 Windbg Preview 버전을 자동으로 설치하고 싶었는데, Store apps를 스크립트로 옮기는 과정이 복잡하더군요. 다운로드 링크를 직접 주는 사이트를 발견해서 작업을 해보았으나, 권한이 없다는 말이 계속 떠서... ㅜㅜ 깔끔하게 포기했습니다. 나중에 chocolatey에 추가되길 간절히 기원하고 있습니다.

잡담이 길었네요! 제가 많이 사용하는 애플리케이션만 추가해놓고, 저는 보통 시작 - 검색 기능으로 애플리케이션을 실행하는 것을 선호해서 (깔끔한 걸 좋아합니다.) 사실 바탕화면 바로가기나 작업 표시줄 고정 기능을 많이 사용하지 않아요. 이 부분도 취향에 맞게 수정하셔서 사용하시면 됩니다.

전체 소스 코드는 [github](https://github.com/idioth/malvm)에 업로드되어 있으니, 많은 구경 부탁드리고 피드백 또한 언제나 환영입니다! 감사합니다 :)

# Reference

[https://dotnet-helpers.com/powershell/create-shortcuts-on-desktops-using-powershell/](https://dotnet-helpers.com/powershell/create-shortcuts-on-desktops-using-powershell/)

[https://stackoverflow.com/questions/31720595/pin-program-to-taskbar-using-ps-in-windows-10](https://stackoverflow.com/questions/31720595/pin-program-to-taskbar-using-ps-in-windows-10)